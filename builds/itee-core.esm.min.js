import{isNull as t,isUndefined as e,isNotString as s,isString as o,isObject as r,isArrayOfString as n,isArrayOfObject as i}from"itee-validators";import a from"crypto";import{toEnum as u}from"itee-utils";const l=new Uint8Array(256);let h=l.length;function c(){return h>l.length-16&&(a.randomFillSync(l),h=0),l.slice(h,h+=16)}var p=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function d(t){return"string"==typeof t&&p.test(t)}const g=[];for(let t=0;t<256;++t)g.push((t+256).toString(16).substr(1));function m(t,e,s){const o=(t=t||{}).random||(t.rng||c)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e){s=s||0;for(let t=0;t<16;++t)e[s+t]=o[t];return e}return function(t,e=0){const s=(g[t[e+0]]+g[t[e+1]]+g[t[e+2]]+g[t[e+3]]+"-"+g[t[e+4]]+g[t[e+5]]+"-"+g[t[e+6]]+g[t[e+7]]+"-"+g[t[e+8]]+g[t[e+9]]+"-"+g[t[e+10]]+g[t[e+11]]+g[t[e+12]]+g[t[e+13]]+g[t[e+14]]+g[t[e+15]]).toLowerCase();if(!d(s))throw TypeError("Stringified UUID is invalid");return s}(o)}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class f{get name(){return this._name}set name(o){const r="Expect a String";if(t(o))throw new Error(`name cannot be null ! ${r}`);if(e(o))throw new Error(`name cannot be undefined ! ${r}`);if(s(o))throw new ReferenceError("TAbstractObject.name: Value cannot be null or undefined. Expect an  !");this._name=o}getName(t){return t.name=this.name,this}setName(t){return this.name=t,this}get uuid(){return this._uuid}set uuid(s){const o="Expect an uuid v4.";if(t(s))throw new Error(`uuid cannot be null ! ${o}`);if(e(s))throw new Error(`uuid cannot be undefined ! ${o}`);if(!d(s)||4!==function(t){if(!d(t))throw TypeError("Invalid UUID");return parseInt(t.substr(14,1),16)}(s))throw new Error(`Unable to set invalid uuid [${s}] ! ${o}`);this._uuid=s}getUuid(t){return t.uuid=this.uuid,this}setUuid(t){return this.uuid=t,this}constructor(t={}){const e=m(),s={uuid:e,name:`${this.constructor.name}_${e}`,logger:null,...t};this.uuid=s.uuid,this.name=s.name,this.logger=s.logger}}const b=u({Console:1,Html:2,Toast:4,File:8,Database:16,All:255}),_=u({Message:0,Progress:1,Time:2}),w=u({None:0,Debug:1,Info:2,Warning:4,Error:8,All:255});class v{static _levelToString(t){let e="";switch(t){case w.Info:e="info";break;case w.Warning:e="warning";break;case w.Error:e="error";break;default:e="unknownLogLevel"}return e}constructor(t={}){const e={outputLevel:w.Error,outputs:b.Console,...t};this.isLogger=!0,this.outputLevel=e.outputLevel,this.outputs=e.outputs,this._logsArray=[],this._timers={},this._counterTrace=0}get outputLevel(){return this._outputLevel}set outputLevel(s){const o="Expect a value from LogLevel enum.";if(t(s))throw new Error(`OutputLevel cannot be null ! ${o}`);if(e(s))throw new Error(`OutputLevel cannot be undefined ! ${o}`);this._outputLevel=s}get outputs(){return this._outputs}set outputs(s){const o="Expect a value from LogOutput enum.";if(t(s))throw new Error(`Output cannot be null ! ${o}`);if(e(s))throw new Error(`Output cannot be undefined ! ${o}`);this._outputs=s}_formatTrace(t,e){const s=`${v._levelToString(t)}_${this._counterTrace}`;if(o(e))this._logsArray[s]=e;else if(r(e))this._logsArray[s]=v._formatObjectError(e);else if(n(e))this._logsArray[s]=e.toString();else if(i(e)){this._logsArray[s]="";for(let s=0,o=e.length;s<o;s++)this._formatTrace(t,e[s])}else this._logsArray[s]=e?e.toString():"Empty log data !";return this._counterTrace++,this._logsArray[s]}dispatch(t){const e=t.type;switch(e){case _.Message:this._dispatchMessage(t);break;case _.Progress:this._dispatchProgress(t);break;case _.Time:this._dispatchTime(t);break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}}_dispatchMessage(t){const e=t.level,s=t.message;switch(e){case w.Error:this.outputLevel&w.Error&&this._dispatchErrorMessage(s);break;case w.Warning:this.outputLevel&w.Warning&&this._dispatchWarningMessage(s);break;case w.Info:this.outputLevel&w.Info&&this._dispatchInfoMessage(s);break;case w.Debug:this.outputLevel&w.Debug&&this._dispatchDebugMessage(s);break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}}_dispatchErrorMessage(t){if(this.outputs&b.Console&&console.error(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-error"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchWarningMessage(t){if(this.outputs&b.Console&&console.warn(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-warning"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchInfoMessage(t){if(this.outputs&b.Console&&console.log(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-info"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchDebugMessage(t){if(this.outputs&b.Console&&console.log(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-info"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchProgress(t){const e=t.level;let s=t.message;switch(e){case w.Info:this.outputLevel&w.Info&&this._dispatchInfoProgress(s);break;case w.Debug:this.outputLevel&w.Debug&&this._dispatchDebugProgress(s);break;default:throw new RangeError(`Invalid progress level parameter: ${e}`)}}_dispatchInfoProgress(t){if(this.outputs&b.Console&&console.log(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-info"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchDebugProgress(t){if(this.outputs&b.Console&&console.log(t),this.outputs&b.Html){const e=document.createElement("span");e.classList.add("log-info"),e.innerText=t,document.body.appendChild(e)}this.outputs,b.Toast,this.outputs,b.File,this.outputs,b.Database}_dispatchTime(t){console.log(t.message)}debug(t){this.dispatch({type:_.Message,level:w.Debug,message:t})}log(t){this.dispatch({type:_.Message,level:w.Info,message:t})}warn(t){this.dispatch({type:_.Message,level:w.Warning,message:t})}error(t){this.dispatch({type:_.Message,level:w.Error,message:t})}progress(t){if(t.preventDefault(),t.cancelable&&t.stopImmediatePropagation(),t.lengthComputable){const e=t.type,s=t.loaded,o=t.total,r=`${e}: ${Math.round(s/o*1e4)/100}% [${s}/${o}]`;this.dispatch({type:_.Progress,level:w.Info,message:r})}}startChronoFor(t){this._timers[t]=(new Date).getTime()}stopChronoFor(t){const e=`${t} take ${(new Date).getTime()-this._timers[t]}ms.`;this.dispatch({type:_.Time,level:w.Debug,message:e})}setOutputLevel(t){return this.outputLevel=t,this}setOutput(t){return this.outputs=t,this}}const E=new v;export{E as DefaultLogger,f as TAbstractObject,v as TLogger};
